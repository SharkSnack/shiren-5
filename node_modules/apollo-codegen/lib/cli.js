#!/usr/bin/env node
'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _process = require('process');

var _process2 = _interopRequireDefault(_process);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _ = require('.');

var _errors = require('./errors');

require('source-map-support/register');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Make sure unhandled errors in async code are propagated correctly
_process2.default.on('unhandledRejection', function (error) {
  throw error;
});

_process2.default.on('uncaughtException', handleError);

function handleError(error) {
  (0, _errors.logError)(error);
  _process2.default.exit(1);
}

_yargs2.default.command(['introspect-schema <schema>', 'download-schema'], 'Generate an introspection JSON from a local GraphQL file or from a remote GraphQL server', {
  output: {
    demand: true,
    describe: 'Output path for GraphQL schema file',
    default: 'schema.json',
    normalize: true,
    coerce: _path2.default.resolve
  },
  header: {
    alias: 'H',
    describe: 'Additional header to send to the server as part of the introspection query request',
    type: 'array',
    coerce: function coerce(arg) {
      var additionalHeaders = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(arg), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var header = _step.value;

          var _header$split = header.split(/\s*:\s*/),
              _header$split2 = (0, _slicedToArray3.default)(_header$split, 2),
              name = _header$split2[0],
              value = _header$split2[1];

          if (!(name && value)) {
            throw new _errors.ToolError('Headers should be specified as "Name: Value"');
          }
          additionalHeaders[name] = value;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return additionalHeaders;
    }
  },
  insecure: {
    alias: 'K',
    describe: 'Allows "insecure" SSL connection to the server',
    type: 'boolean'
  }
}, function () {
  var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(argv) {
    var schema, output, header, insecure, urlRegex;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            schema = argv.schema, output = argv.output, header = argv.header, insecure = argv.insecure;
            urlRegex = /^https?:\/\//i;

            if (!urlRegex.test(schema)) {
              _context.next = 7;
              break;
            }

            _context.next = 5;
            return (0, _.downloadSchema)(schema, output, header, insecure);

          case 5:
            _context.next = 9;
            break;

          case 7:
            _context.next = 9;
            return (0, _.introspectSchema)(schema, output);

          case 9:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}()).command(['print-schema [schema]'], 'Print the provided schema in the GraphQL schema language format', {
  schema: {
    demand: true,
    describe: 'Path to GraphQL introspection query result',
    default: 'schema.json',
    normalize: true,
    coerce: _path2.default.resolve
  },
  output: {
    demand: true,
    describe: 'Output path for GraphQL schema language file',
    default: 'schema.graphql',
    normalize: true,
    coerce: _path2.default.resolve
  }
}, function () {
  var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(argv) {
    var schema, output;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            schema = argv.schema, output = argv.output;
            _context2.next = 3;
            return (0, _.printSchema)(schema, output);

          case 3:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, undefined);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}()).command('generate [input...]', 'Generate code from a GraphQL schema and query documents', {
  schema: {
    demand: true,
    describe: 'Path to GraphQL schema file',
    default: 'schema.json',
    normalize: true,
    coerce: _path2.default.resolve
  },
  output: {
    describe: 'Output directory for the generated files',
    normalize: true,
    coerce: _path2.default.resolve
  },
  target: {
    demand: false,
    describe: 'Code generation target language',
    choices: ['swift', 'json', 'ts', 'typescript', 'flow'],
    default: 'swift'
  },
  "passthrough-custom-scalars": {
    demand: false,
    describe: "Don't attempt to map custom scalars [temporary option]",
    default: false
  },
  "custom-scalars-prefix": {
    demand: false,
    describe: "Prefix for custom scalars. (Implies that passthrough-custom-scalars is true if set)",
    default: '',
    normalize: true
  }
}, function (argv) {
  var input = argv.input;

  // Use glob if the user's shell was unable to expand the pattern

  if (input.length === 1 && _glob2.default.hasMagic(input[0])) {
    input = _glob2.default.sync(input[0]);
  }

  var inputPaths = input.map(function (input) {
    return _path2.default.resolve(input);
  })
  // Sort to normalize different glob expansions between different terminals.
  .sort();

  var options = { passthroughCustomScalars: argv["passthrough-custom-scalars"] || argv["custom-scalars-prefix"] !== '', customScalarsPrefix: argv["custom-scalars-prefix"] || '' };
  (0, _.generate)(inputPaths, argv.schema, argv.output, argv.target, options);
}).fail(function (message, error) {
  handleError(error ? error : new _errors.ToolError(message));
}).help().version().strict().argv;
//# sourceMappingURL=cli.js.map
{"version":3,"sources":["../src/compilation.js"],"names":["compileToIR","printIR","builtInScalarTypes","isBuiltInScalarType","type","has","schema","document","compiler","Compiler","operations","forEach","operation","name","value","compileOperation","fragments","fragment","compileFragment","typesUsed","typesUsedSet","fragmentMap","definitions","definition","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","compiledFragmentMap","add","getFields","field","addTypeUsed","fragmentName","operationDefinition","filePath","operationName","operationType","variables","variableDefinitions","map","node","variable","source","withTypenameFieldAddedWhereNeeded","rootType","groupedVisitedFragmentSet","groupedFieldSet","collectFields","selectionSet","undefined","fragmentsReferencedSet","resolveFields","fields","fragmentsReferenced","fragmentDefinition","typeCondition","possibleTypes","possibleTypesForType","fragmentSpreads","inlineFragments","parentType","Error","String","selections","selection","FIELD","fieldName","responseName","alias","args","argumentsFromAST","arguments","directives","INLINE_FRAGMENT","inlineFragmentType","effectiveType","FRAGMENT_SPREAD","fragmentNamed","fragmentType","visitedFragmentSet","get","set","getPossibleTypes","fieldSet","filter","length","firstField","isConditional","some","directiveName","directive","description","bareType","subSelectionGroupedVisitedFragmentSet","subSelectionGroupedFieldSet","mergeSelectionSets","fragmentSpreadsForParentType","resolveInlineFragments","values","fragmentsReferencedFromFragment","fragmentReferenced","collectPossibleTypes","isPossibleType","keys","typenameField","NAME","ast","isOperationRootType","getQueryType","getMutationType","getSubscriptionType","typeInfo","leave","SelectionSet","getParentType","sourceAt","location","body","slice","start","end","arg","concat","inlineFragment"],"mappings":"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","file":"compilation.js","sourcesContent":["import {\n  print,\n  visit,\n  visitWithTypeInfo,\n  typeFromAST,\n  getNamedType,\n  isAbstractType,\n  isEqualType,\n  isTypeSubTypeOf,\n  Kind,\n  TypeInfo,\n  isType,\n  isCompositeType,\n  GraphQLScalarType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  GraphQLError\n} from 'graphql';\n\nimport {\n  isTypeProperSuperTypeOf,\n  getOperationRootType,\n  getFieldDef,\n  valueFromValueNode,\n  filePathForNode\n} from './utilities/graphql';\n\nimport {\n  join,\n  block,\n  wrap,\n  indent\n} from './utilities/printing';\n\nconst builtInScalarTypes = new Set([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);\n\nfunction isBuiltInScalarType(type) {\n  return builtInScalarTypes.has(type);\n}\n\n// Parts of this code are adapted from graphql-js\n\nexport function compileToIR(schema, document) {\n  const compiler = new Compiler(schema, document);\n\n  const operations = Object.create(null);\n\n  compiler.operations.forEach(operation => {\n    operations[operation.name.value] = compiler.compileOperation(operation)\n  });\n\n  const fragments = Object.create(null);\n\n  compiler.fragments.forEach(fragment => {\n    fragments[fragment.name.value] = compiler.compileFragment(fragment)\n  });\n\n  const typesUsed = compiler.typesUsed;\n\n  return { schema, operations, fragments, typesUsed };\n}\n\nexport class Compiler {\n  constructor(schema, document) {\n    this.schema = schema;\n\n    this.typesUsedSet = new Set();\n\n    this.fragmentMap = Object.create(null);\n    this.operations = [];\n\n    for (const definition of document.definitions) {\n      switch (definition.kind) {\n        case Kind.OPERATION_DEFINITION:\n          this.operations.push(definition);\n          break;\n        case Kind.FRAGMENT_DEFINITION:\n          this.fragmentMap[definition.name.value] = definition;\n          break;\n      }\n    }\n\n    this.compiledFragmentMap = Object.create(null);\n  }\n\n  addTypeUsed(type) {\n    if (this.typesUsedSet.has(type)) return;\n    \n    if (type instanceof GraphQLEnumType ||\n        type instanceof GraphQLInputObjectType ||\n        (type instanceof GraphQLScalarType && !isBuiltInScalarType(type))) {\n      this.typesUsedSet.add(type);\n    }\n    if (type instanceof GraphQLInputObjectType) {\n      for (const field of Object.values(type.getFields())) {\n        this.addTypeUsed(getNamedType(field.type));\n      }\n    }\n  }\n\n  get typesUsed() {\n    return Array.from(this.typesUsedSet);\n  }\n\n  fragmentNamed(fragmentName) {\n    return this.fragmentMap[fragmentName];\n  }\n\n  get fragments() {\n    return Object.values(this.fragmentMap);\n  }\n\n  compileOperation(operationDefinition) {\n    const filePath = filePathForNode(operationDefinition);\n    const operationName = operationDefinition.name.value;\n    const operationType = operationDefinition.operation;\n\n    const variables = operationDefinition.variableDefinitions.map(node => {\n      const name = node.variable.name.value;\n      const type = typeFromAST(this.schema, node.type);\n      this.addTypeUsed(getNamedType(type));\n      return { name, type };\n    });\n\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, operationDefinition));\n\n    const rootType = getOperationRootType(this.schema, operationDefinition);\n\n    const groupedVisitedFragmentSet = new Map();\n    const groupedFieldSet = this.collectFields(rootType, operationDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\n\n    const fragmentsReferencedSet = Object.create(null);\n    const { fields } = this.resolveFields(rootType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\n\n    return { filePath, operationName, operationType, variables, source, fields, fragmentsReferenced };\n  }\n\n  compileFragment(fragmentDefinition) {\n    const filePath = filePathForNode(fragmentDefinition);\n    const fragmentName = fragmentDefinition.name.value;\n\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, fragmentDefinition));\n\n    const typeCondition = typeFromAST(this.schema, fragmentDefinition.typeCondition);\n    const possibleTypes = this.possibleTypesForType(typeCondition)\n\n    const groupedVisitedFragmentSet = new Map();\n    const groupedFieldSet = this.collectFields(typeCondition, fragmentDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\n\n    const fragmentsReferencedSet = Object.create(null);\n    const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(typeCondition, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\n\n    return { filePath, fragmentName, source, typeCondition, possibleTypes, fields, fragmentSpreads, inlineFragments, fragmentsReferenced };\n  }\n\n  collectFields(parentType, selectionSet, groupedFieldSet = Object.create(null), groupedVisitedFragmentSet = new Map()) {\n    if (!isCompositeType(parentType)) {\n      throw new Error(`parentType should be a composite type, but is \"${String(parentType)}\"`);\n    }\n\n    for (const selection of selectionSet.selections) {\n      switch (selection.kind) {\n        case Kind.FIELD: {\n          const fieldName = selection.name.value;\n          const responseName = selection.alias ? selection.alias.value : fieldName;\n\n          const field = getFieldDef(this.schema, parentType, selection);\n          if (!field) {\n            throw new GraphQLError(`Cannot query field \"${fieldName}\" on type \"${String(parentType)}\"`, [selection]);\n          }\n\n          if (groupedFieldSet) {\n            if (!groupedFieldSet[responseName]) {\n              groupedFieldSet[responseName] = [];\n            }\n\n            groupedFieldSet[responseName].push([parentType, {\n              responseName,\n              fieldName,\n              args: argumentsFromAST(selection.arguments),\n              type: field.type,\n              directives: selection.directives,\n              selectionSet: selection.selectionSet\n            }]);\n          }\n          break;\n        }\n        case Kind.INLINE_FRAGMENT: {\n          const typeCondition = selection.typeCondition;\n          const inlineFragmentType = typeCondition ?\n            typeFromAST(this.schema, typeCondition) :\n            parentType;\n\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : inlineFragmentType;\n          if (inlineFragmentType !== effectiveType && !isTypeProperSuperTypeOf(this.schema, inlineFragmentType, effectiveType)) {\n            break;\n          }\n\n          this.collectFields(\n            effectiveType,\n            selection.selectionSet,\n            groupedFieldSet,\n            groupedVisitedFragmentSet\n          );\n          break;\n        }\n        case Kind.FRAGMENT_SPREAD: {\n          const fragmentName = selection.name.value;\n\n          const fragment = this.fragmentNamed(fragmentName);\n          if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\n\n          const typeCondition = fragment.typeCondition;\n          const fragmentType = typeFromAST(this.schema, typeCondition)\n\n          if (groupedVisitedFragmentSet) {\n            let visitedFragmentSet = groupedVisitedFragmentSet.get(parentType);\n            if (!visitedFragmentSet) {\n              visitedFragmentSet = {};\n              groupedVisitedFragmentSet.set(parentType, visitedFragmentSet);\n            }\n\n            if (visitedFragmentSet[fragmentName]) continue;\n            visitedFragmentSet[fragmentName] = true;\n          }\n\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : fragmentType;\n\n          this.collectFields(\n            effectiveType,\n            fragment.selectionSet,\n            null,\n            groupedVisitedFragmentSet\n          );\n          break;\n        }\n      }\n    }\n\n    return groupedFieldSet;\n  }\n\n  possibleTypesForType(type) {\n    if (isAbstractType(type)) {\n      return this.schema.getPossibleTypes(type);\n    } else {\n      return [type];\n    }\n  }\n\n  mergeSelectionSets(parentType, fieldSet, groupedVisitedFragmentSet) {\n    const groupedFieldSet = Object.create(null);\n\n    for (const [,field] of fieldSet) {\n      const selectionSet = field.selectionSet;\n\n      if (selectionSet) {\n        this.collectFields(parentType, selectionSet, groupedFieldSet, groupedVisitedFragmentSet);\n      }\n    }\n\n    return groupedFieldSet;\n  }\n\n  resolveFields(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\n    const fields = [];\n\n    for (let [responseName, fieldSet] of Object.entries(groupedFieldSet)) {\n      fieldSet = fieldSet.filter(([typeCondition,]) => isTypeSubTypeOf(this.schema, parentType, typeCondition));\n      if (fieldSet.length < 1) continue;\n\n      const [,firstField] = fieldSet[0];\n      const fieldName = firstField.fieldName;\n      const args = firstField.args;\n      const type = firstField.type;\n\n      let field = { responseName, fieldName, type };\n\n      if (args && args.length > 0) {\n        field.args = args;\n      }\n\n      const isConditional = fieldSet.some(([,field]) => {\n        return field.directives && field.directives.some(directive => {\n          const directiveName = directive.name.value;\n          return directiveName == 'skip' || directiveName == 'include';\n        });\n      });\n\n      if (isConditional) {\n        field.isConditional = true;\n      }\n\n      const description = parentType.getFields()[fieldName].description;\n\n      if (description) {\n        field.description = description\n      }\n\n      const bareType = getNamedType(type);\n\n      this.addTypeUsed(bareType);\n\n      if (isCompositeType(bareType)) {\n        const subSelectionGroupedVisitedFragmentSet = new Map();\n        const subSelectionGroupedFieldSet = this.mergeSelectionSets(\n          bareType,\n          fieldSet,\n          subSelectionGroupedVisitedFragmentSet\n        );\n\n        const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(\n          bareType,\n          subSelectionGroupedFieldSet,\n          subSelectionGroupedVisitedFragmentSet,\n          fragmentsReferencedSet\n        );\n        Object.assign(field, { fields, fragmentSpreads, inlineFragments });\n      }\n\n      fields.push(field);\n    }\n\n    const fragmentSpreads = this.fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet);\n    const inlineFragments = this.resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n\n    if (fragmentsReferencedSet) {\n      Object.assign(fragmentsReferencedSet, ...groupedVisitedFragmentSet.values());\n\n      // TODO: This is a really inefficient way of keeping track of fragments referenced by other fragments\n      // We need to either cache compiled fragments or find a way to make resolveFields smarter\n      for (let fragmentName of fragmentSpreads) {\n        const fragment = this.fragmentNamed(fragmentName);\n        if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\n        const { fragmentsReferenced: fragmentsReferencedFromFragment } = this.compileFragment(fragment);\n        for (let fragmentReferenced of fragmentsReferencedFromFragment) {\n          fragmentsReferencedSet[fragmentReferenced] = true;\n        }\n      }\n    }\n\n    return { fields, fragmentSpreads, inlineFragments };\n  }\n\n  resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\n    return this.collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet).map(typeCondition => {\n      const { fields, fragmentSpreads } = this.resolveFields(\n        typeCondition,\n        groupedFieldSet,\n        groupedVisitedFragmentSet,\n        fragmentsReferencedSet\n      );\n      const possibleTypes = this.possibleTypesForType(typeCondition)\n      return { typeCondition, possibleTypes, fields, fragmentSpreads };\n    });\n  }\n\n  collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet) {\n    if (!isAbstractType(parentType)) return [];\n\n    const possibleTypes = new Set();\n\n    for (const fieldSet of Object.values(groupedFieldSet)) {\n      for (const [typeCondition,] of fieldSet) {\n        if (this.schema.isPossibleType(parentType, typeCondition)) {\n          possibleTypes.add(typeCondition);\n        }\n      }\n    }\n\n    // Also include type conditions for fragment spreads\n    if (groupedVisitedFragmentSet) {\n      for (const effectiveType of groupedVisitedFragmentSet.keys()) {\n        if (this.schema.isPossibleType(parentType, effectiveType)) {\n          possibleTypes.add(effectiveType);\n        }\n      }\n    }\n\n    return Array.from(possibleTypes);\n  }\n\n  fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet) {\n    if (!groupedVisitedFragmentSet) return [];\n\n    let fragmentSpreads = new Set();\n\n    for (const [effectiveType, visitedFragmentSet] of groupedVisitedFragmentSet) {\n      if (!isTypeProperSuperTypeOf(this.schema, effectiveType, parentType)) continue;\n\n      for (const fragmentName of Object.keys(visitedFragmentSet)) {\n        fragmentSpreads.add(fragmentName);\n      }\n    }\n\n    return Array.from(fragmentSpreads);\n  }\n}\n\nconst typenameField = { kind: Kind.FIELD, name: { kind: Kind.NAME, value: '__typename' } };\n\nfunction withTypenameFieldAddedWhereNeeded(schema, ast) {\n  function isOperationRootType(type) {\n    return type === schema.getQueryType() ||\n      type === schema.getMutationType() ||\n      type === schema.getSubscriptionType();\n  }\n\n  const typeInfo = new TypeInfo(schema);\n\n  return visit(ast, visitWithTypeInfo(typeInfo, {\n    leave: {\n      SelectionSet: node => {\n        const parentType = typeInfo.getParentType();\n\n        if (!isOperationRootType(parentType)) {\n          return { ...node, selections: [typenameField, ...node.selections] };\n        }\n      }\n    }\n  }));\n}\n\nfunction sourceAt(location) {\n  return location.source.body.slice(location.start, location.end);\n}\n\nfunction argumentsFromAST(args) {\n  return args.map(arg => {\n    return { name: arg.name.value, value: valueFromValueNode(arg.value) };\n  });\n}\n\nexport function printIR({ fields, inlineFragments, fragmentSpreads }) {\n  return fields && wrap('<', join(fragmentSpreads, ', '), '> ')\n    + block(fields.map(field =>\n      `${field.name}: ${String(field.type)}` + wrap(' ', printIR(field))\n    ).concat(inlineFragments && inlineFragments.map(inlineFragment =>\n      `${String(inlineFragment.typeCondition)}` + wrap(' ', printIR(inlineFragment)))));\n}\n"]}
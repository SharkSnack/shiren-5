"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.onPreBootstrap = onPreBootstrap;
exports.onCreateDevServer = onCreateDevServer;

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _glob = _interopRequireDefault(require("glob"));

var _path = _interopRequireDefault(require("path"));

var _webpack = _interopRequireDefault(require("webpack"));

var _multer = _interopRequireDefault(require("multer"));

var express = _interopRequireWildcard(require("express"));

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _actions = require("../../redux/actions");

var _webpackErrorUtils = require("../../utils/webpack-error-utils");

var _formatWebpackMessages = _interopRequireDefault(require("react-dev-utils/formatWebpackMessages"));

var _dotenv = _interopRequireDefault(require("dotenv"));

var _chokidar = _interopRequireDefault(require("chokidar"));

var _pathToRegexp = _interopRequireDefault(require("path-to-regexp"));

var _cookie = _interopRequireDefault(require("cookie"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const isProductionEnv = process.env.gatsby_executing_command !== `develop`;

const createWebpackConfig = async ({
  siteDirectoryPath,
  functionsDirectory,
  store,
  reporter
}) => {
  const compiledFunctionsDir = _path.default.join(siteDirectoryPath, `.cache`, `functions`);

  const files = await new Promise((resolve, reject) => {
    (0, _glob.default)(`**/*.{js,ts}`, {
      cwd: functionsDirectory
    }, (err, files) => {
      if (err) {
        reject(err);
      } else {
        resolve(files);
      }
    });
  });

  if ((files === null || files === void 0 ? void 0 : files.length) === 0) {
    reporter.warn(`No functions found in directory: ${_path.default.relative(siteDirectoryPath, functionsDirectory)}`);
  }

  const knownFunctions = [];
  knownFunctions.forEach(f => f.apiRoute);
  files.map(file => {
    const {
      dir,
      name
    } = _path.default.parse(file); // Ignore the original extension as all compiled functions now end with js.


    const compiledFunctionName = _path.default.join(dir, name + `.js`);

    const compiledPath = _path.default.join(compiledFunctionsDir, compiledFunctionName);

    const finalName = (0, _gatsbyCoreUtils.urlResolve)(dir, name === `index` ? `` : name);
    knownFunctions.push({
      apiRoute: finalName,
      originalFilePath: file,
      relativeCompiledFilePath: compiledFunctionName,
      absoluteCompiledFilePath: compiledPath,
      matchPath: (0, _gatsbyCoreUtils.getMatchPath)(finalName)
    });
  });
  store.dispatch(_actions.internalActions.setFunctions(knownFunctions)); // Write out manifest for use by `gatsby serve` and plugins

  _fsExtra.default.writeFileSync(_path.default.join(compiledFunctionsDir, `manifest.json`), JSON.stringify(knownFunctions, null, 4)); // Load environment variables from process.env.GATSBY_* and .env.* files.
  // Logic is shared with webpack.config.js
  // node env should be DEVELOPMENT | PRODUCTION as these are commonly used in node land


  const nodeEnv = process.env.NODE_ENV || `${defaultNodeEnv}`; // config env is dependent on the env that it's run, this can be anything from staging-production
  // this allows you to set use different .env environments or conditions in gatsby files

  const configEnv = process.env.GATSBY_ACTIVE_ENV || nodeEnv;

  const envFile = _path.default.join(siteDirectoryPath, `./.env.${configEnv}`);

  let parsed = {};

  try {
    parsed = _dotenv.default.parse(_fsExtra.default.readFileSync(envFile, {
      encoding: `utf8`
    }));
  } catch (err) {
    if (err.code !== `ENOENT`) {
      report.error(`There was a problem processing the .env file (${envFile})`, err);
    }
  }

  const envObject = Object.keys(parsed).reduce((acc, key) => {
    acc[key] = JSON.stringify(parsed[key]);
    return acc;
  }, {});
  const varsFromProcessEnv = Object.keys(process.env).reduce((acc, key) => {
    acc[key] = JSON.stringify(process.env[key]);
    return acc;
  }, {}); // Don't allow overwriting of NODE_ENV, PUBLIC_DIR as to not break gatsby things

  envObject.NODE_ENV = JSON.stringify(nodeEnv);
  envObject.PUBLIC_DIR = JSON.stringify(`${siteDirectoryPath}/public`);
  const mergedEnvVars = Object.assign(envObject, varsFromProcessEnv);
  const processEnvVars = Object.keys(mergedEnvVars).reduce((acc, key) => {
    acc[`process.env.${key}`] = mergedEnvVars[key];
    return acc;
  }, {
    "process.env": `({})`
  });
  const entries = {};
  knownFunctions.forEach(({
    originalFilePath
  }) => {
    const filePath = _path.default.join(functionsDirectory, originalFilePath); // Get path without the extension (as it could be ts or js)


    const parsedFile = _path.default.parse(originalFilePath);

    const compiledNameWithoutExtension = _path.default.join(parsedFile.dir, parsedFile.name);

    entries[compiledNameWithoutExtension] = filePath;
  });
  const config = {
    entry: entries,
    output: {
      path: compiledFunctionsDir,
      filename: `[name].js`,
      libraryTarget: `commonjs2`
    },
    target: `node`,
    mode: isProductionEnv ? `production` : `development`,
    // watch: !isProductionEnv,
    module: {
      rules: [{
        test: [/.js$/, /.ts$/],
        exclude: /node_modules/,
        use: {
          loader: `babel-loader`,
          options: {
            presets: [`@babel/typescript`]
          }
        }
      }]
    },
    plugins: [new _webpack.default.DefinePlugin(processEnvVars)]
  };
  return config;
};

async function onPreBootstrap({
  reporter,
  store
}) {
  const activity = reporter.activityTimer(`Compiling Gatsby Functions`);
  activity.start();
  const {
    program: {
      directory: siteDirectoryPath
    }
  } = store.getState();

  const functionsDirectoryPath = _path.default.join(siteDirectoryPath, `src/api`);

  const functionsDirectory = _path.default.resolve(siteDirectoryPath, functionsDirectoryPath);

  reporter.verbose(`Attaching functions to development server`);

  const compiledFunctionsDir = _path.default.join(siteDirectoryPath, `.cache`, `functions`);

  await _fsExtra.default.ensureDir(compiledFunctionsDir);

  try {
    // We do this ungainly thing as we need to make accessible
    // the resolve/reject functions to our shared callback function
    // eslint-disable-next-line
    await new Promise(async (resolve, reject) => {
      const config = await createWebpackConfig({
        siteDirectoryPath,
        functionsDirectory,
        store,
        reporter
      });

      function callback(err, stats) {
        const rawMessages = stats.toJson({
          moduleTrace: false
        });

        if (rawMessages.warnings.length > 0) {
          (0, _webpackErrorUtils.reportWebpackWarnings)(rawMessages.warnings, reporter);
        }

        if (err) return reject(err);
        const errors = stats.compilation.errors || []; // If there's errors, reject in production and print to the console
        // in development.

        if (isProductionEnv) {
          if (errors.length > 0) return reject(stats.compilation.errors);
        } else {
          const formated = (0, _formatWebpackMessages.default)({
            errors: rawMessages.errors.map(e => e.message),
            warnings: []
          });
          reporter.error(formated.errors);
        } // Log success in dev


        if (!isProductionEnv) {
          reporter.success(`Re-building functions`);
        }

        return resolve();
      }

      if (isProductionEnv) {
        (0, _webpack.default)(config).run(callback);
      } else {
        // When in watch mode, you call things differently
        let compiler = (0, _webpack.default)(config).watch({}, callback); // Watch for env files to change and restart the webpack watcher.

        _chokidar.default.watch([`${siteDirectoryPath}/.env*`, `${siteDirectoryPath}/src/api/**/*`], {
          ignoreInitial: true
        }).on(`all`, (event, path) => {
          // Ignore change events from the API directory
          if (event === `change` && path.includes(`/src/api/`)) {
            return;
          }

          reporter.log(`Restarting function watcher due to change to "${path}"`); // Otherwise, restart the watcher

          compiler.close(async () => {
            const config = await createWebpackConfig({
              siteDirectoryPath,
              functionsDirectory,
              store,
              reporter
            });
            compiler = (0, _webpack.default)(config).watch({}, callback);
          });
        });
      }
    });
  } catch (e) {
    activity.panic(`Failed to compile Gatsby Functions.`, e);
  }

  activity.end();
}

async function onCreateDevServer({
  reporter,
  app,
  store
}) {
  reporter.verbose(`Attaching functions to development server`);
  app.use(`/api/*`, (0, _multer.default)().none(), express.urlencoded({
    extended: true
  }), (req, res, next) => {
    const cookies = req.headers.cookie;

    if (!cookies) {
      return next();
    }

    req.cookies = _cookie.default.parse(cookies);
    return next();
  }, express.text(), express.json(), express.raw(), async (req, res, next) => {
    const {
      "0": pathFragment
    } = req.params;
    const {
      functions
    } = store.getState(); // Check first for exact matches.

    let functionObj = functions.find(({
      apiRoute
    }) => apiRoute === pathFragment);

    if (!functionObj) {
      // Check if there's any matchPaths that match.
      // We loop until we find the first match.
      functions.some(f => {
        let exp;
        const keys = [];

        if (f.matchPath) {
          exp = (0, _pathToRegexp.default)(f.matchPath, keys);
        }

        if (exp && exp.exec(pathFragment) !== null) {
          functionObj = f;
          const matches = [...pathFragment.match(exp)].slice(1);
          const newParams = {};
          matches.forEach((match, index) => newParams[keys[index].name] = match);
          req.params = newParams;
          return true;
        } else {
          return false;
        }
      });
    }

    if (functionObj) {
      reporter.verbose(`Running ${functionObj.apiRoute}`);
      const start = Date.now();
      const pathToFunction = functionObj.absoluteCompiledFilePath;

      try {
        delete require.cache[require.resolve(pathToFunction)];

        const fn = require(pathToFunction);

        const fnToExecute = fn && fn.default || fn;
        await Promise.resolve(fnToExecute(req, res));
      } catch (e) {
        reporter.error(e); // Don't send the error if that would cause another error.

        if (!res.headersSent) {
          res.status(500).send(`Error when executing function "${functionObj.originalFilePath}": "${e.message}"`);
        }
      }

      const end = Date.now();
      reporter.log(`Executed function "/api/${functionObj.apiRoute}" in ${end - start}ms`);
    } else {
      next();
    }
  });
}
//# sourceMappingURL=gatsby-node.js.map